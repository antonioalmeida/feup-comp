options
{
  LOOKAHEAD= 1;

}

PARSER_BEGIN(Yal)
public class Yal
{
  public static void main(String args []) throws ParseException
  {
    Yal myYal = new Yal(System.in);
    SimpleNode root = myYal.Program(); // devolve referência para o nó raiz da árvore
    root.dump(""); // imprime no ecrã a árvore
  }
}

PARSER_END(Yal)

< DEFAULT >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

/* reserved words */
< DEFAULT >
TOKEN :
{
  < RELA_OP :
    ">"
  | "<"
  | "<="
  | ">="
  | "=="
  | "!=" >
| < ADDSUB_OP :
    "+"
  | "-" >
| < ARITH_OP :
    "*"
  | "/"
  | "<<"
  | ">>"
  | ">>>" >
| < BITWISE_OP :
    "&"
  | "|"
  | "^" >
| < NOT_OP : "!" >
| < WHILE : "while" >
| < IF : "if" >
| < ELSE : "else" >
| < ASSIGN : "=" >
| < ASPA : "\"" >
| < LPAR : "(" >
| < RPAR : ")" >
| < VIRG : "," >
| < PVIRG : ";" >
| < LCHAVETA : "{" >
| < RCHAVETA : "}" >
| < FUNCTION : "function" >
| < MODULE : "module" >
| < SIZE : "size" >
}

< DEFAULT >
TOKEN :
{
  < INTEGER : (< DIGIT >)+ >
| < ID :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >
| < #DIGIT : [ "0"-"9" ] >
| < STRING : "\"" ([ "a"-"z", "A"-"Z", "0"-"9", ":", " ", "=" ])+ "\"" >
}

SimpleNode Program() :
{}
{
  < MODULE >
  {
    return jjtThis;
  }
}

void Module() : 
{Token t;}
{
  < MODULE > t=< ID >{jjtThis.setValue(t.image);} < LCHAVETA >
  (
    Declaration()
  )*
  (
    Function()
  )*
  < RCHAVETA >
}

void Declaration() :
{}
{
  (
    Element()
  )
  (
    < ASSIGN >
    (
      (
        "[" ArraySize() "]"
      )
    | (< ADDSUB_OP >)? < INTEGER >
    )
  )?
  < PVIRG >
}

void Function() :
{}
{
  (
    (
      < FUNCTION >
      (
        ArrayElement()
      | ScalarElement()
      )
      < ASSIGN > < ID > 
      < LPAR >
      (
        Varlist()
      )?
      < RPAR >
    )
  |
    (
      < FUNCTION > < ID > < LPAR >
      (
        Varlist()
      )?
      < RPAR >
    )
  )
  < LCHAVETA > Stmtlst() < RCHAVETA >
}

void Varlist() :
{}
{
  (
    ArrayElement()
  | ScalarElement()
  )
  (
    < VIRG >
    (
      ArrayElement()
    | ScalarElement()
    )
  )*
}

void Element() #void:{Token t;}{
	t=<ID> (
		ArrayElementNoID(t.image)
	  | ScalarElementNoID(t.image)
	)
}

void ArrayElementNoID(String id) #ArrayElement:
{}
{
	{jjtThis.setValue(id);}
  "[" "]"
}

void ScalarElementNoID(String id) #ScalarElement:
{}
{
	{jjtThis.setValue(id);}
   ""
}

void ArrayElement() :
{}
{
  < ID > "[" "]"
}

void ScalarElement() :
{}
{
  < ID >
}

void Stmtlst() :
{}
{
  (
    Stmt()
  )*
}

void Stmt() :
{}
{
  While()
| If()
| Assign()
| Call() < PVIRG >
}

void Assign() :
{}
{
  Lhs() < ASSIGN > Rhs() < PVIRG >
}

void Lhs() :
{}
{
  ArrayAccess()
| ScalarAccess()
}

void Rhs() :
{}
{
  (
    Term()
    (
      (
        < ARITH_OP >
      | < BITWISE_OP >
      | < ADDSUB_OP >
      )
      Term()
    )?
  )
| "[" ArraySize() "]"
}

void ArraySize() :
{}
{
  ScalarAccess()
| < INTEGER >
}

void Term() :
{}
{
  (< ADDSUB_OP >)?
  (
    < INTEGER >
  | Call()
  | ArrayAccess()
  | ScalarAccess()
  )
}

void Exprtest() :
{}
{
  < LPAR > Lhs() < RELA_OP > Rhs() < RPAR >
}

void While() :
{}
{
  < WHILE > Exprtest() < LCHAVETA > Stmtlst() < RCHAVETA >
}

void If() :
{}
{
  < IF > Exprtest() < LCHAVETA > Stmtlst() < RCHAVETA >
  (
    < ELSE > < LCHAVETA > 
    Stmtlst() < RCHAVETA >
  )?
}

void Call() :
{}
{
  < ID > ("." < ID >)? < LPAR >
  (
    ArgumentList()
  )?
  < RPAR >
}

void ArgumentList() :
{}
{
  Argument()
  (
    < VIRG > Argument()
  )*
}

void Argument() :
{}
{
  (
    < ID >
  | < STRING >
  | < INTEGER >
  )
}

void ArrayAccess() :
{}
{
  < ID > "[" Index() "]"
}

void ScalarAccess() :
{}
{
  < ID > ("." < SIZE >)?
}

void Index() :
{}
{
  < ID >
| < INTEGER >
}
