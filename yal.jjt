

options
{
  LOOKAHEAD= 1;
  MULTI = true;
}

PARSER_BEGIN(Yal)
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
public class Yal
{
		
  private static Yal myYal;
  
  public static void main(String args []) throws ParseException
  {
    
    if( validArgs(args) == false)
    	return;
    else { 
    	SimpleNode root = myYal.Program(); // devolve referência para o nó raiz da árvore
    	root.dump(""); // imprime no ecrã a árvore
    }
  }

  public static File validFilePath(String filePath) {
		File file = new File(filePath);
		
		if(file.exists())
			return file;		
		else
			return null;
			
  }
  	
  public static boolean validArgs(String args []) {

		if(args.length > 1) { 
			System.out.println("Invalid number of arguments");
			return false;
		}
		
		else if(args.length == 0)
			myYal = new Yal(System.in);

		else if(args.length == 1) {
                        File file;
                        if( (file = validFilePath(args[0])) == null) {
                                System.out.println("Invalid file Path");
                                return false;
                        }
                        else {
                                FileInputStream stream;
								try {
									stream = new FileInputStream(file);
									myYal = new Yal(stream);
								} catch (FileNotFoundException e) {
									System.out.println("Error in stream constructor: ");
									e.printStackTrace();
								}
                                
                        }
        }
		

		return true;
  }

  public static void errorSkipTo(ParseException e, String errorMessage, int... skipTargets) {
    System.out.println("Syntatic Error on " + errorMessage + ". " + e.toString());
    Token t1;
    boolean foundTarget = false;

    do {
      t1 = getNextToken();

      for (int token : skipTargets) {
        if(token == t1.kind) 
          foundTarget = true;
      }
    } while (!foundTarget);
  }

  public static void coverageBlock() throws ParseException {
	Token t1;
    t1 = getNextToken();
    if(t1.kind == LCHAVETA) {
      StmtlstError();
    }
  }
}

PARSER_END(Yal)

< DEFAULT >
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

/* reserved words */
< DEFAULT >
TOKEN :
{
  < RELA_OP :
    ">"
  | "<"
  | "<="
  | ">="
  | "=="
  | "!=" >
| < ADDSUB_OP :
    "+"
  | "-" >
| < ARITH_OP :
    "*"
  | "/"
  | "<<"
  | ">>"
  | ">>>" >
| < BITWISE_OP :
    "&"
  | "|"
  | "^" >
| < NOT_OP : "!" >
| < WHILE : "while" >
| < IF : "if" >
| < ELSE : "else" >
| < ASSIGN : "=" >
| < ASPA : "\"" >
| < LPAR : "(" >
| < RPAR : ")" >
| < VIRG : "," >
| < PVIRG : ";" >
| < LCHAVETA : "{" >
| < RCHAVETA : "}" >
| < FUNCTION : "function" >
| < MODULE : "module" >
| < SIZE : "size" >
}

< DEFAULT >
TOKEN :
{
  < INTEGER : (< DIGIT >)+ >
| < ID :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
    )* >
| < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >
| < #DIGIT : [ "0"-"9" ] >
| < STRING : "\"" ([ "a"-"z", "A"-"Z", "0"-"9", ":", " ", "=" ])+ "\"" >
}

SimpleNode Program() :
{}
{
  Module()
  {
    return jjtThis;
  }
}

void Module() : 
{Token t;}
{
  try { 
  < MODULE > t=< ID >{jjtThis.jjtSetValue(t.image);} < LCHAVETA > }catch(ParseException e) {
    System.out.println("Syntatic error on module declaration. " + e.toString());
    Token t1;
    return;    
  }
  try { 
  (
    Declaration()
  )* }catch(ParseException e) {
		errorSkipTo(e, "declarations module area", PVIRG);
     }
  try { 
  (
    Function()
  )*
  < RCHAVETA > } catch(ParseException e) {
    errorSkipTo(e, "functions module area", RCHAVETA);
  }
}

void Declaration() :
{}
{
  (
    Element()
  )
  (
    < ASSIGN >
    (
      (
        "[" ArraySize() "]"
      )
    | (< ADDSUB_OP >)? < INTEGER >
    )
  )?
  < PVIRG >
}

void Function() : { Token t;}
{ 
  try {
    < FUNCTION > t=< ID >{jjtThis.jjtSetValue(t.image);}
    (
      (
        (
          ArrayElementNoID(t.image)
        | ScalarElementNoID(t.image)
        )
       	FunctionAssign()
        < LPAR >
        (
          Varlist()
        )?
        < RPAR >
      )
    |
      (
  	 < LPAR >
        (
          Varlist()
        )?
        < RPAR >
      )
    )
  } 
  catch(ParseException e) {
    errorSkipTo(e, "function declaration", RPAR);
  }
  try { 
  < LCHAVETA > Stmtlst() < RCHAVETA > } catch(ParseException e) {
		errorSkipTo(e, "function body", RCHAVETA);
    }
}

void FunctionAssign() : {Token t;}
{
	
	 < ASSIGN > t=< ID > 
	 {jjtThis.jjtSetValue(t.image);}
}

void Varlist() : { Token t1, t2; }
{ t1 = < ID >
  (
    ArrayElementNoID(t1.image)
  | ScalarElementNoID(t1.image)
  )
  (
    < VIRG >  t2 = < ID >
    (
     ArrayElementNoID(t2.image)
    | ScalarElementNoID(t2.image)
    )
  )*
}

void Element() :{Token t;}{
	t=<ID> (
		ArrayElementNoID(t.image)
	  | ScalarElementNoID(t.image)
	)
	{jjtThis.jjtSetValue(t.image);}
}

void ArrayElementNoID(String id) #ArrayElement:
{}
{
	{jjtThis.jjtSetValue(id);}
  "[" "]"
}


void ScalarElementNoID(String id) #ScalarElement:
{}
{
	{jjtThis.jjtSetValue(id);}
}

void ArrayElement() :
{}
{
  < ID > "[" "]"
}

void ScalarElement() :
{}
{
  < ID >
}

void Stmtlst() #void:
{}
{
  (
    Stmt()
  )*
}

void StmtlstError() :
{}
{
  (
    Stmt()
  )*"}"
}

void Stmt() #void: { Token t; }
{
  try { 
    While()
  | If() 
  |(
    t = < ID >
  ( 
     AssignNoPoint(t.image)
  | CallLPARVirg(t.image) |  "."PointAssignCallVirg(t.image))) 
  } 
  catch(ParseException e) {
  	System.out.println("Syntatic error during Statement declaration. " + e.toString());
      Token t2;

      do {
        t2 = getNextToken();

        /*
        if(t2.kind == LCHAVETA) {
          StmtlstError();
          return;
        }*/
      } while(t2.kind != PVIRG);
    }
}

void PointAssignCallVirg(String id) #void:
{}
{
  (
    < ID > CallLPARVirg(id)) | (< SIZE > AssignNoPoint(id))
}

void Assign() :
{}
{
  Lhs() < ASSIGN > Rhs() < PVIRG >
}

void AssignNoID(String id) #Assign:
{ }
{
  
  try {
    LhsNoID(id) < ASSIGN > Rhs() < PVIRG >
  }
  catch(ParseException e) {
    errorSkipTo(e, "assignment", PVIRG);
  }
}

void AssignNoPoint(String id) #Assign:
{ }
{
  
  try {
    LhsNoPoint(id) < ASSIGN > Rhs() < PVIRG >
  }
  catch(ParseException e) {
    errorSkipTo(e, "assignment", PVIRG);
  }
}
  

void Lhs() #void:
{Token t;}
{
  t = < ID >(
  ArrayAccessNoID(t.image)
| ScalarAccessNoID(t.image))
}

void LhsNoID(String id) #void:
{ }
{
  /*{jjtThis.jjtSetValue(id);}*/
  ArrayAccessNoID(id)
| ScalarAccessNoID(id)
}
  
void LhsNoPoint(String id) #void:
{ }
{
  ArrayAccessNoID(id)
| ScalarAccessNothing(id)
}
  

void Rhs():
{Token t=null;}
{
  (
    Term()
    (
      (
        t=< ARITH_OP >
      | t=< BITWISE_OP >
      | t=< ADDSUB_OP >
      )
      {jjtThis.jjtSetValue(t.image);}
      Term()
    )?
  )
| "[" ArraySize() "]"


}

void ArraySize() :
{Token t;}
{
  ScalarAccess()
| t=< INTEGER >{jjtThis.jjtSetValue(t.image);}
}

void Term() :
{
  Token t,t2=null;
}
{
  (t2=< ADDSUB_OP >{jjtThis.set_sign(t2.image);})?
  (
    t=< INTEGER >{jjtThis.jjtSetValue(t.image);}
  |
    (
      t = < ID >
      (CallLPAR(t.image) | "." PointCallScalarAccess(t.image) | ArrayAccessNoID(t.image) 
		| ScalarAccessNothing(t.image))  
        
    )
  )
  
}



void Exprtest() :
{Token t;}
{
  < LPAR > Lhs() t=< RELA_OP > Rhs() < RPAR >
  {jjtThis.jjtSetValue(t.image);}
}

void While() :
{}
{
    try {
      < WHILE > Exprtest() < LCHAVETA > 
    }
    catch(ParseException e) {
      errorSkipTo(e, "WHILE statement declaration", LCHAVETA);
    }
    Stmtlst() < RCHAVETA >
}

void If() :
{}
{
  try {
    < IF > Exprtest() < LCHAVETA > Stmtlst() < RCHAVETA >
  }
  catch (ParseException e) {
    errorSkipTo(e, "IF statement", RCHAVETA);
  }

  try {
    (
      < ELSE > < LCHAVETA >
      Stmtlst() < RCHAVETA >
    )?
  }
  catch (ParseException e) {
    System.out.println("Syntatic error on ELSE statement. " + e.toString());
    Token t1;
    boolean hasBrackets = false;
    // If left brackets is found, skip to right bracket
    // otherwise, skip to ';'

    // TODO: Refactor this later
    do {
      t1 = getNextToken();
      if(t1.kind == LCHAVETA) {
        hasBrackets = true;
        break;
      }
    } while (t1.kind != PVIRG);

    if(hasBrackets) {
      do {
        t1 = getNextToken();
      } while (t1.kind != RCHAVETA);
    }
  }
}
/*
void Call() :
{}
{
  < ID > ("." < ID >)? < LPAR >
  (
    ArgumentList()
  )?
  < RPAR >
}*/

void CallNoID(String id) #Call:
{Token t=null; }
{
  ("." t=< ID >{jjtThis.set_type(t.image);})? 
  try { 
  < LPAR >
  (	
    ArgumentList()
  )?
  < RPAR > } catch (ParseException e) {
    errorSkipTo(e, "function call", RPAR, PVIRG);


  }
   {jjtThis.jjtSetValue(id);}
}

void CallNoIDVirg(String id) #Call:
{Token t=null; }
{
  ("." t=< ID >{jjtThis.set_type(t.image);})?
  try { 
  < LPAR >
  (	
    ArgumentList()
  )?
  < RPAR > < PVIRG >} catch (ParseException e) {
    errorSkipTo(e, "function call", RPAR, PVIRG);

    coverageBlock();
  }
  {jjtThis.jjtSetValue(id);}
}

void CallLPAR (String id) #Call:
{Token t=null; }
{
  try { 
  < LPAR >
  (	
    ArgumentList()
  )?
  < RPAR > } catch (ParseException e) {
    errorSkipTo(e, "function call", RPAR, PVIRG);

    
  }
  {jjtThis.jjtSetValue(id);}
	
}
  
   
void CallLPARVirg (String id) #Call:
{Token t=null; }
{
  try { 
  < LPAR >
  (	
    ArgumentList()
  )?
  < RPAR > < PVIRG >} catch (ParseException e) {
    errorSkipTo(e, "function call", RPAR, PVIRG);

    coverageBlock();
  }
  {jjtThis.jjtSetValue(id);}
	
}

void ArgumentList() #void:
{}
{
  Argument()
  (
    < VIRG > Argument()
  )*
}

void Argument() :
{Token t;}
{
  (
    t=< ID >
  | t=< STRING > 
  | t=< INTEGER > 
  )
  {jjtThis.jjtSetValue(t.image);}
}

void ArrayAccess() :
{}
{
  < ID > "[" Index() "]"
}

void ArrayAccessNoID(String id) #ArrayAccess:
{ }
{
  {jjtThis.jjtSetValue(id); }
  "[" Index() "]"
}

void ScalarAccess() #void:
{Token t;}
{
  t=< ID > ScalarAccessNoID(t.image)
}

void ScalarAccessNoID(String id) #ScalarAccess:
{ Token t=null;}
{
  {jjtThis.jjtSetValue(id); }
  ("." < SIZE >{jjtThis.set_size_access(true);})?

}

void ScalarAccessNothing(String id) #ScalarAccess:
{ Token t=null; }
{
  {jjtThis.jjtSetValue(id); }
    
} 

void PointCallScalarAccess(String id) #void:
{
  
}
{
  (
    < ID > CallLPAR(id)) | (< SIZE > ScalarAccessNothing(id))
}

/*void CallScalarAccessVirgPoint(String id) #void:
{
  
}
{
  (
    < ID > CallLPARVirg(id)) | (< SIZE > ScalarAccessNothing(id))
}*/

void Index() :
{Token t;}
{
( t=< ID >
| t=< INTEGER >)
{jjtThis.jjtSetValue(t.image); }
}
