/* Generated By:JJTree: Do not edit this line. ASTAssign.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=true,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
package parser;
import java.util.Vector;
import semantic.Symbol;
public
class ASTAssign extends SimpleNode {
    public ASTAssign(int id) {
        super(id, false, false, true);
    }

    public ASTAssign(Yal p, int id) {
        super(p, id, false, false, true);
    }

    public boolean analyseSymbolTable() {
        if(getChildren() == null)
            return false;

        // lhs
        SimpleNode lhsChild = (SimpleNode) getChildren()[0];
        
        if(lhsChild.getSizeArray()) {
        	//System.out.println("Semantic Error: Can't assign the size of array "+lhsChild.value+".");
        	printSemanticError("Can't assign the size of array "+lhsChild.getValue());
        	return false;
        }
        Symbol.Type lhsType = lhsChild.getReturnType();
        

        // rhs
        SimpleNode rhsChild = (SimpleNode) getChildren()[1];
       Vector<Symbol.Type> rhsTypes = ((ASTRhs) rhsChild).getReturnTypes();

        String lhsSymbol = (String) lhsChild.jjtGetValue();
        String rhsSymbol = (String) rhsChild.jjtGetValue();
        
        if(!rhsTypes.contains(Symbol.Type.SCALAR) && !rhsTypes.contains(Symbol.Type.ARRAY)) {
        	//System.out.println("Semantic Error: On expression assignement of "+lhsSymbol+".");
        	printSemanticError("On expression assignement of "+lhsSymbol);
        	return false;
        }
        else if(!rhsTypes.contains(Symbol.Type.SCALAR) && rhsTypes.contains(Symbol.Type.ARRAY)) {
        	if(!initializeSymbol(lhsSymbol, Symbol.Type.ARRAY, true)) {
        		//System.out.println("Semantic Error: " + lhsSymbol + " has been declared as a scalar, reassigned as an array.");
        		printSemanticError(lhsSymbol + " has been declared as a scalar, reassigned as an array");
        		return false;
        	}

            return true;
        }
        else if(lhsChild.toString().equals("ArrayAccess"))
        	return true;
        else {
        	Symbol.Type type = Symbol.Type.SCALAR;
        	if(lhsType.equals(Symbol.Type.ARRAY))
        	   type = Symbol.Type.ARRAY;
            
        
        	if(type.equals(Symbol.Type.ARRAY) && !verifySymbolTypes(lhsSymbol, true, Symbol.Type.ARRAY)) {
        		 //System.out.println("Semantic Error: Can't initialize array " + lhsSymbol+" as its size should have been declared before.");
                 printSemanticError("Can't initialize array " + lhsSymbol+" as its size should have been declared before");
        		 return false;
        	}
        	else
        		initializeSymbol(lhsSymbol, type, true);
        }

        return true;
    }

    public Symbol.Type getReturnType() {
        return Symbol.Type.VOID;  
    }
    
    public boolean isArrayAssigned() {
    	SimpleNode rhs = (SimpleNode) this.jjtGetChild(1);

    	SimpleNode arrayAssigned = (SimpleNode) rhs.jjtGetChild(0);
    	
        if (arrayAssigned.id==YalTreeConstants.JJTARRAYASSIGNED)
        	return true;
        return false;
    }
    
    public boolean isArrayAcess() {
    	SimpleNode lhs = (SimpleNode) this.jjtGetChild(0);

    	
        if (lhs.id==YalTreeConstants.JJTARRAYACCESS)
        	return true;
        return false;
    }
    
	public boolean hasAnIncrement() {
		SimpleNode rhs = (SimpleNode) jjtGetChild(1);
		SimpleNode lhs = (SimpleNode) jjtGetChild(0);

		//is local var
		if (getSymbolTable().containsSymbolName(lhs.getValue()))
			//is a sum
			if (rhs.getValue().equals("+")) {
				//case i = i + 1
				if (lhs.getValue().equals(((SimpleNode) rhs.jjtGetChild(0).jjtGetChild(0)).getValue())
						&& ((SimpleNode) rhs.jjtGetChild(1).jjtGetChild(0)).getId() == YalTreeConstants.JJTINTEGER)
					return true;
				//case i = 1 + i
				if (lhs.getValue().equals(((SimpleNode) rhs.jjtGetChild(1).jjtGetChild(0)).getValue())
						&& ((SimpleNode) rhs.jjtGetChild(0).jjtGetChild(0)).getId() == YalTreeConstants.JJTINTEGER)
					return true;
			}
		return false;
		

    }
	
	public boolean isInsideWhileOrIf() {
		SimpleNode functionNode = (SimpleNode) jjtGetParent();
		while (functionNode.getId() != YalTreeConstants.JJTFUNCTION) {
			if (functionNode.getId() == YalTreeConstants.JJTIFSTATEMENT || functionNode.getId() == YalTreeConstants.JJTWHILE)
				return true;
			functionNode = (SimpleNode) functionNode.jjtGetParent();
		}

		return false;
	}

}
/* JavaCC - OriginalChecksum=b3b7f5a4d1f623c6f3813a4a1e0a425d (do not edit this line) */
