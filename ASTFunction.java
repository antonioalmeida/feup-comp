import java.util.Vector;

import semantic.Symbol;
import semantic.Symbol.Type;
import utils.Pair;

/* Generated By:JJTree: Do not edit this line. ASTFunction.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTFunction extends SimpleNode {
	public ASTFunction(int id) {
		super(id, true, false);
	}

	public ASTFunction(Yal p, int id) {
		super(p, id, true, false);
	}
	
	//TODO: See what this means
	@SuppressWarnings("unchecked")
	public boolean addFunctionEntry() {
		System.out.println("addFunction " + toString(""));
		symbolTable = getAssignedSymbolTable();
        functionTable = getAssignedFunctionTable();
        String functionName = "";
        String returnValue = "";
        Symbol.Type returnType = Symbol.Type.VOID;
        Vector<Symbol.Type> argumentTypes = new Vector<Symbol.Type>();
        Vector<Pair> parameters = new Vector<Pair>();
       
        if(children != null && children.length > 1 && 
        		children[1].toString().equals("FunctionAssign")) {
        	returnValue = ((SimpleNode) children[0]).value;
        	returnType = ((SimpleNode) children[0]).getReturnType();
        	functionName = ((SimpleNode) children[1]).value;
        	if(children.length > 2 && children[2].toString().equals("Varlist")) {
        		Pair pair = ((ASTVarlist) children[2]).getArguments();
        		argumentTypes = (Vector<Type>) pair.getValue();
        		parameters = (Vector<Pair>) pair.getKey();
        	}
        	
        }
        else {
        	functionName = value;
        	if(children != null && children.length > 1
        			&& children[1].toString().equals("Varlist")) {
        		Pair pair = ((ASTVarlist) children[1]).getArguments();
        		argumentTypes = (Vector<Type>) pair.getValue();
        		parameters = (Vector<Pair>) pair.getKey(); 
        	}
        }
        
        if(! functionTable.initializeFunction(functionName, argumentTypes, parameters, returnType, returnValue)) {
        	System.out.println("Semantic Error: A function with the same signature has already been defined");
        	return false;
        }
		
		
		return true;

	  	//TODO: add header analysing logic
	}
  
	public String generateCode() {
		String generatedCode = "";
		generatedCode += ".method public static " + this.value + "\n";
		
		if(this.value.equals("main"))
			generatedCode += "([Ljava/lang/String;)V\n";
		//else 
		//generatedCode += "Ljava/lang/String;)V";

		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode) children[i];
				if (n != null) {
					generatedCode += n.generateCode();
				}
			}
		}
		generatedCode += "\nreturn\n";
		generatedCode += ".end method\n\n";

		return generatedCode;

	}
	
	public boolean analyse() {
		boolean result = true;
	    
        if(children != null) {
            for(Node child : children) {
                if(!child.analyse())
                    result = false;
            }
        }
        
        if(!analyseSymbolTable())
            result = false;
       

        return result;
	}

}
/* JavaCC - OriginalChecksum=87cbf5972d530f3221d99b5c8270925a (do not edit this line) */
